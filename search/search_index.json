{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduktion Denne portef\u00f8lje er en samling af mit arbejde og mine refleksioner fra mit 4. semester, hvor jeg har valgt at specialisere mig i Backend-udvikling og Blazor. Gennem mit projekt for Odense Golfklub har jeg haft mulighed for at kombinere teori og praksis ved at udvikle en l\u00f8sning, der effektivt h\u00e5ndterer golfspilleres data og pr\u00e6stationer. Mit m\u00e5l var at automatisere manuelle opgaver, som statistikberegninger, for at give tr\u00e6nerne bedre indsigt i spillernes pr\u00e6stationer og frig\u00f8re tid til andre opgaver. Ved at anvende teknologier som Clean Architecture, CQRS og JWT i backend og Blazor i frontend har jeg skabt en dynamisk og brugervenlig applikation. Projektet har udfordret mig b\u00e5de teknisk og personligt, og jeg ser det som en vigtig milep\u00e6l i min udvikling som softwareudvikler. Min Specialisering Jeg har valgt at specialisere mig inden for backend-udvikling og Blazor-webapplikationer. Jeg arbejder p\u00e5 et projekt for Odense Golfklub, hvor fokus er at udvikle en l\u00f8sning, der giver golftr\u00e6neren bedre indsigt i sine spillere og deres pr\u00e6stationer. Projektet automatiserer manuelle opgaver som statistikanalyser, hvilket sparer tid og \u00f8ger effektiviteten. Gennem projektet har jeg arbejdet med principper som Clean Architecture og CQRS i backend, samtidig med at jeg har skabt en dynamisk og brugervenlig frontend i Blazor, der integrerer med en sikker backend via API'er. I frontend har jeg is\u00e6r arbejdet med interaktive funktioner som s\u00f8gning, sortering og farvekodning af data for at skabe en mere visuel og brugervenlig oplevelse. L\u00e6ringsm\u00e5l for Backend Viden Forst\u00e5else af Clean Architecture og dets anvendelse til at opdele ansvar i lag som Domain, Application, Infrastructure og Presentation (API). Kendskab til CQRS-pattern for adskillelse af foresp\u00f8rgsler og kommandoer i backend. Forst\u00e5else af brugen af JWT-tokens til sikker API-kommunikation. Indsigt i datavalidering ved hj\u00e6lp af FluentValidation. F\u00e6rdigheder Udvikle en backend baseret p\u00e5 Clean Architecture for at sikre skalerbarhed og vedligeholdelse. Implementere CQRS-pattern for bedre struktur og modularitet i backend. Bygge sikre API'er ved hj\u00e6lp af JWT-tokens til autentifikation og autorisation. Sikre datakvalitet med datavalidering via FluentValidation. Kompetencer Kunne selvst\u00e6ndigt designe og implementere en backend-struktur baseret p\u00e5 moderne designm\u00f8nstre. Kritisk evaluere sikkerhedsmekanismer og datavalidering i forhold til projektets behov. Relatere backend-udvikling til bredere IT-udfordringer og samarbejde effektivt med frontend-udvikling. L\u00e6ringsm\u00e5l for Blazor Viden Forst\u00e5else af komponentbaseret udvikling i Blazor WebAssembly. Kendskab til integration mellem frontend og backend via API-kald. Indsigt i h\u00e5ndtering af JWT-tokens i frontend til autentifikation. Forst\u00e5else af dynamisk datavisualisering med teknikker som farvekodning og interaktive tabeller. F\u00e6rdigheder Udvikle interaktive Blazor-komponenter, der underst\u00f8tter databinding og events. Implementere frontend-backend-kommunikation med sikker h\u00e5ndtering af JWT-tokens. Bygge funktioner som s\u00f8gning, sortering og dynamisk datavisualisering. H\u00e5ndtere fejl og undtagelser i API-kommunikation p\u00e5 en brugervenlig m\u00e5de. Kompetencer Kunne selvst\u00e6ndigt designe og implementere en brugervenlig frontend med avancerede funktioner. Arbejde iterativt og forbedre UI baseret p\u00e5 feedback fra brugere og PO. Relatere frontend-udvikling til brugeroplevelse og backend-integration. Arkitektur og Teknologi Clean Architecture For at sikre en skalerbar og vedligeholdelsesvenlig l\u00f8sning har jeg anvendt Clean Architecture som grundlag for backend-strukturen. Denne tilgang adskiller ansvarsomr\u00e5der i fire lag: - Domain : Indeholder kerneentiteter og deres relationer. - Application : H\u00e5ndterer use cases og validering. - Infrastructure : Sikrer dataadgang og integration. - API : Eksponerer funktionalitet til frontend. Diagrammet nedenfor illustrerer, hvordan lagene interagerer, og hvordan afh\u00e6ngigheder kun peger indad for at sikre l\u00f8s kobling: Ved at bruge denne struktur kunne jeg nemt tilf\u00f8je nye funktioner som statistikberegninger og dataindsamling uden at p\u00e5virke andre dele af systemet. CQRS og MediatR For at optimere systemets struktur og modularitet implementerede jeg CQRS (Command Query Responsibility Segregation sammen med MediatR. Dette m\u00f8nster adskiller l\u00e6se- og skriveoperationer og g\u00f8r koden mere overskuelig og testbar. Eksempel: - Kommando : CreateTeeCommandHandler h\u00e5ndterer oprettelse af en ny tee med validering og datalagring. - Foresp\u00f8rgsel : GetTeeDetailRequestHandler henter detaljerede oplysninger om en tee fra databasen. Denne opdeling gav mulighed for at implementere \u00e6ndringer og tilf\u00f8jelser uden at p\u00e5virke eksisterende funktionalitet (Se logbogen for mere detaljeret dokumentation om CQRS-implementeringen). JWT-tokens og sikkerhed For at sikre systemets API-endpoints har jeg anvendt JWT-tokens. Dette giver en robust sikkerhedsl\u00f8sning, der beskytter data mod uautoriseret adgang. Ved hj\u00e6lp af [Authorize]-attributten kunne jeg yderligere begr\u00e6nse adgang til bestemte endpoints baseret p\u00e5 brugerroller, s\u00e5som \u201cAdmin\u201d for oprettelse af nye golfklubber. For at g\u00f8re test og udvikling mere effektiv integrerede jeg Swagger, som underst\u00f8tter autentifikation med JWT-tokens direkte i dokumentationen. Dette gjorde det muligt for udviklere at teste API\u2019et hurtigt og sikkert. Statistikberegninger og Visualisering En central del af projektet var udviklingen af statistikfunktioner, der hj\u00e6lper tr\u00e6nere med at analysere spillerpr\u00e6stationer. Systemet beregner avancerede statistikker som: - Fairway Hits % : Procentdelen af fairways, spilleren ramte. - Green in Regulation % : Hvor ofte spilleren n\u00e5ede greenen inden for \"Par - 2\". - Hulspil Score : En vigtig funktion i systemet er beregningen af spillerens Hulspil Score, der repr\u00e6senterer gennemsnittet af slag pr. hul i en given runde. For at give en fair vurdering justeres scorer, der er v\u00e6rre end double bogey, automatisk til double bogey, f\u00f8r de indg\u00e5r i beregningen. Dette sikrer, at ekstremsituationer ikke p\u00e5virker gennemsnittet uforholdsm\u00e6ssigt meget (Krav tilf\u00f8jet af PO under udviklingen af systemet). Eksempel p\u00e5 beregning: public double CalculateAvgMatchPlayScorePerRound(List<PlayingHoleDto> playingHoles) { // Group playing holes by roundId var roundScores = playingHoles.GroupBy(ph => ph.RoundId) .Select(g => { double totalAdjustedScore = 0.0; foreach (var ph in g) { // calculate the adjusted score double adjustedScore = ph.Score > (ph.Par + 2) ? (ph.Par + 2) : ph.Score; totalAdjustedScore += adjustedScore; } return totalAdjustedScore; }) .ToList(); // Calculate the avg adjusted score = MatcPlayScoreAvg. return roundScores.Any() ? roundScores.Average() : 0.0; } Disse beregninger pr\u00e6senteres visuelt som grafer og farvekodede tabeller, der g\u00f8r det nemt for tr\u00e6nere at identificere forbedringsomr\u00e5der for deres spillere. Refleksioner Planl\u00e6gning og m\u00e5l Selvom jeg ikke havde en fastlagt skemastruktur, arbejdede jeg med klare m\u00e5l og en overordnet plan, som blev visualiseret ved hj\u00e6lp af et Gantt-diagram. Diagrammet hjalp mig med at organisere mit arbejde og sikre, at jeg holdt fokus p\u00e5 projektets vigtigste leverancer. Planen omfattede faser som: - Analyse og design : Systemanalyse, kravspecifikation og design af systemarkitektur. - Backend-udvikling : Implementering af kernefunktioner, autorisation og statistikberegninger. - Frontend-udvikling : Udvikling af UI-komponenter og integration med backend. - Feedback og iterationer : Justering af l\u00f8sninger baseret p\u00e5 feedback fra Product Owner. Ved at arbejde med planen kunne jeg nemt opdele komplekse opgaver i mindre trin og prioritere dem baseret p\u00e5 deres betydning for projektets l\u00e6ringsm\u00e5l. Arbejde uden fast struktur P\u00e5 trods af den overordnede plan arbejdede jeg uden en fast daglig struktur, hvilket gav mig frihed til at udforske og l\u00e6re i mit eget tempo. Dette var b\u00e5de en styrke og en udfordring. P\u00e5 den ene side kunne jeg fokusere p\u00e5 de omr\u00e5der, der kr\u00e6vede mest opm\u00e6rksomhed, men p\u00e5 den anden side savnede jeg nogle gange en fast rytme til at holde mig fuldt organiseret. Hvis jeg havde arbejdet med en strammere tidsplan, kunne jeg m\u00e5ske have udnyttet tiden endnu mere effektivt. Feedback og kommunikation Samarbejdet med Product Owner var en vigtig del af projektet, og feedbacken fra ham gav os flere nyttige indsigter. Under en pr\u00e6sentation viste vi vores API-endpoints ved hj\u00e6lp af Swagger for at demonstrere systemets tekniske funktionalitet. PO n\u00e6vnte dog, at han ikke fik s\u00e5 meget ud af denne tilgang. Han ville have haft mere gavn af en simpel visuel pr\u00e6sentation, s\u00e5som et diagram eller en tegning, der kunne forklare systemets funktioner p\u00e5 et overordnet niveau. Denne oplevelse mindede mig om vigtigheden af at tilpasse kommunikationen til m\u00e5lgruppen. Ikke alle interessenter har behov for dyb teknisk indsigt, og fremover vil jeg fokusere mere p\u00e5 at bruge visuelle v\u00e6rkt\u00f8jer og diagrammer til at formidle komplekse l\u00f8sninger p\u00e5 en mere tilg\u00e6ngelig m\u00e5de. Dette vil sikre, at interessenter forst\u00e5r v\u00e6rdien af l\u00f8sningen og dens anvendelse. Opn\u00e5else af l\u00e6ringsm\u00e5l Jeg har opn\u00e5et betydelige fremskridt i forhold til mine l\u00e6ringsm\u00e5l, is\u00e6r inden for backend-udvikling og systemarkitektur: Clean Architecture gav mig v\u00e6rdifuld erfaring i at skabe en fleksibel og vedligeholdelsesvenlig kodebase. Jeg l\u00e6rte at opdele applikationen i lag, hvilket gjorde det lettere at implementere nye funktioner og rette fejl. CQRS og Repository Pattern hjalp mig med at skabe en skalerbar og modular backend. Jeg har l\u00e6rt at strukturere koden med tydelig adskillelse af l\u00e6se- og skriveoperationer ved hj\u00e6lp af MediatR, hvilket har gjort min kodebase mere testbar og vedligeholdelsesvenlig. Autorisering og sikkerhed via JWT-tokens gav mig dybere indsigt i moderne sikkerhedsmekanismer. Jeg forstod, hvordan man implementerer sikker kommunikation og begr\u00e6nser adgang til API-endpoints baseret p\u00e5 brugerroller. Personlig udvikling Dette semester har v\u00e6ret en vigtig l\u00e6ringsrejse. Jeg har ikke kun styrket mine tekniske f\u00e6rdigheder, men ogs\u00e5 udviklet en dybere forst\u00e5else af, hvordan man opbygger systemer, der b\u00e5de er robuste og brugervenlige. Arbejdet med komplekse designm\u00f8nstre og teknologier har forbedret min evne til at analysere problemer og finde effektive l\u00f8sninger. Forbedringsomr\u00e5der Strammere tidsstyring : Selvom planen fungerede godt som en guide, kunne jeg have brugt den mere aktivt til at evaluere mit daglige arbejde og sikre, at jeg holdt mig p\u00e5 rette spor. Tilpasning af kommunikation : Denne erfaring med PO viste mig, at kommunikation skal m\u00e5lrettes mod modtagerens behov. Jeg vil fremover bruge flere visuelle v\u00e6rkt\u00f8jer og forberede alternative m\u00e5der at pr\u00e6sentere teknisk komplekse emner. Udvidelse af frontend-kompetencer : Mit fokus har v\u00e6ret p\u00e5 backend, men der er stadig omr\u00e5der i frontend-udviklingen, hvor jeg kan forbedre mine f\u00e6rdigheder, is\u00e6r inden for brugeroplevelse og design. Konklusion Min erfaring med dette projekt har v\u00e6ret utrolig l\u00e6rerig. Jeg har f\u00e5et praktisk erfaring med at anvende komplekse designprincipper som Clean Architecture og CQRS samt teknologier som JWT. Samtidig har jeg l\u00e6rt vigtigheden af planl\u00e6gning og struktur for at kunne arbejde effektivt. Denne proces har ogs\u00e5 l\u00e6rt mig at tilpasse min kommunikation til m\u00e5lgruppen, hvilket jeg ser som en uvurderlig f\u00e6rdighed fremover. Dette semester har ikke kun styrket mine tekniske kompetencer, men ogs\u00e5 min evne til at reflektere over mit arbejde og finde m\u00e5der at forbedre det p\u00e5.","title":"Projekt"},{"location":"#introduktion","text":"Denne portef\u00f8lje er en samling af mit arbejde og mine refleksioner fra mit 4. semester, hvor jeg har valgt at specialisere mig i Backend-udvikling og Blazor. Gennem mit projekt for Odense Golfklub har jeg haft mulighed for at kombinere teori og praksis ved at udvikle en l\u00f8sning, der effektivt h\u00e5ndterer golfspilleres data og pr\u00e6stationer. Mit m\u00e5l var at automatisere manuelle opgaver, som statistikberegninger, for at give tr\u00e6nerne bedre indsigt i spillernes pr\u00e6stationer og frig\u00f8re tid til andre opgaver. Ved at anvende teknologier som Clean Architecture, CQRS og JWT i backend og Blazor i frontend har jeg skabt en dynamisk og brugervenlig applikation. Projektet har udfordret mig b\u00e5de teknisk og personligt, og jeg ser det som en vigtig milep\u00e6l i min udvikling som softwareudvikler.","title":"Introduktion"},{"location":"#min-specialisering","text":"Jeg har valgt at specialisere mig inden for backend-udvikling og Blazor-webapplikationer. Jeg arbejder p\u00e5 et projekt for Odense Golfklub, hvor fokus er at udvikle en l\u00f8sning, der giver golftr\u00e6neren bedre indsigt i sine spillere og deres pr\u00e6stationer. Projektet automatiserer manuelle opgaver som statistikanalyser, hvilket sparer tid og \u00f8ger effektiviteten. Gennem projektet har jeg arbejdet med principper som Clean Architecture og CQRS i backend, samtidig med at jeg har skabt en dynamisk og brugervenlig frontend i Blazor, der integrerer med en sikker backend via API'er. I frontend har jeg is\u00e6r arbejdet med interaktive funktioner som s\u00f8gning, sortering og farvekodning af data for at skabe en mere visuel og brugervenlig oplevelse.","title":"Min Specialisering"},{"location":"#lringsmal-for-backend","text":"","title":"L\u00e6ringsm\u00e5l for Backend"},{"location":"#viden","text":"Forst\u00e5else af Clean Architecture og dets anvendelse til at opdele ansvar i lag som Domain, Application, Infrastructure og Presentation (API). Kendskab til CQRS-pattern for adskillelse af foresp\u00f8rgsler og kommandoer i backend. Forst\u00e5else af brugen af JWT-tokens til sikker API-kommunikation. Indsigt i datavalidering ved hj\u00e6lp af FluentValidation.","title":"Viden"},{"location":"#frdigheder","text":"Udvikle en backend baseret p\u00e5 Clean Architecture for at sikre skalerbarhed og vedligeholdelse. Implementere CQRS-pattern for bedre struktur og modularitet i backend. Bygge sikre API'er ved hj\u00e6lp af JWT-tokens til autentifikation og autorisation. Sikre datakvalitet med datavalidering via FluentValidation.","title":"F\u00e6rdigheder"},{"location":"#kompetencer","text":"Kunne selvst\u00e6ndigt designe og implementere en backend-struktur baseret p\u00e5 moderne designm\u00f8nstre. Kritisk evaluere sikkerhedsmekanismer og datavalidering i forhold til projektets behov. Relatere backend-udvikling til bredere IT-udfordringer og samarbejde effektivt med frontend-udvikling.","title":"Kompetencer"},{"location":"#lringsmal-for-blazor","text":"","title":"L\u00e6ringsm\u00e5l for Blazor"},{"location":"#viden_1","text":"Forst\u00e5else af komponentbaseret udvikling i Blazor WebAssembly. Kendskab til integration mellem frontend og backend via API-kald. Indsigt i h\u00e5ndtering af JWT-tokens i frontend til autentifikation. Forst\u00e5else af dynamisk datavisualisering med teknikker som farvekodning og interaktive tabeller.","title":"Viden"},{"location":"#frdigheder_1","text":"Udvikle interaktive Blazor-komponenter, der underst\u00f8tter databinding og events. Implementere frontend-backend-kommunikation med sikker h\u00e5ndtering af JWT-tokens. Bygge funktioner som s\u00f8gning, sortering og dynamisk datavisualisering. H\u00e5ndtere fejl og undtagelser i API-kommunikation p\u00e5 en brugervenlig m\u00e5de.","title":"F\u00e6rdigheder"},{"location":"#kompetencer_1","text":"Kunne selvst\u00e6ndigt designe og implementere en brugervenlig frontend med avancerede funktioner. Arbejde iterativt og forbedre UI baseret p\u00e5 feedback fra brugere og PO. Relatere frontend-udvikling til brugeroplevelse og backend-integration.","title":"Kompetencer"},{"location":"#arkitektur-og-teknologi","text":"","title":"Arkitektur og Teknologi"},{"location":"#clean-architecture","text":"For at sikre en skalerbar og vedligeholdelsesvenlig l\u00f8sning har jeg anvendt Clean Architecture som grundlag for backend-strukturen. Denne tilgang adskiller ansvarsomr\u00e5der i fire lag: - Domain : Indeholder kerneentiteter og deres relationer. - Application : H\u00e5ndterer use cases og validering. - Infrastructure : Sikrer dataadgang og integration. - API : Eksponerer funktionalitet til frontend. Diagrammet nedenfor illustrerer, hvordan lagene interagerer, og hvordan afh\u00e6ngigheder kun peger indad for at sikre l\u00f8s kobling: Ved at bruge denne struktur kunne jeg nemt tilf\u00f8je nye funktioner som statistikberegninger og dataindsamling uden at p\u00e5virke andre dele af systemet.","title":"Clean Architecture"},{"location":"#cqrs-og-mediatr","text":"For at optimere systemets struktur og modularitet implementerede jeg CQRS (Command Query Responsibility Segregation sammen med MediatR. Dette m\u00f8nster adskiller l\u00e6se- og skriveoperationer og g\u00f8r koden mere overskuelig og testbar. Eksempel: - Kommando : CreateTeeCommandHandler h\u00e5ndterer oprettelse af en ny tee med validering og datalagring. - Foresp\u00f8rgsel : GetTeeDetailRequestHandler henter detaljerede oplysninger om en tee fra databasen. Denne opdeling gav mulighed for at implementere \u00e6ndringer og tilf\u00f8jelser uden at p\u00e5virke eksisterende funktionalitet (Se logbogen for mere detaljeret dokumentation om CQRS-implementeringen).","title":"CQRS og MediatR"},{"location":"#jwt-tokens-og-sikkerhed","text":"For at sikre systemets API-endpoints har jeg anvendt JWT-tokens. Dette giver en robust sikkerhedsl\u00f8sning, der beskytter data mod uautoriseret adgang. Ved hj\u00e6lp af [Authorize]-attributten kunne jeg yderligere begr\u00e6nse adgang til bestemte endpoints baseret p\u00e5 brugerroller, s\u00e5som \u201cAdmin\u201d for oprettelse af nye golfklubber. For at g\u00f8re test og udvikling mere effektiv integrerede jeg Swagger, som underst\u00f8tter autentifikation med JWT-tokens direkte i dokumentationen. Dette gjorde det muligt for udviklere at teste API\u2019et hurtigt og sikkert.","title":"JWT-tokens og sikkerhed"},{"location":"#statistikberegninger-og-visualisering","text":"En central del af projektet var udviklingen af statistikfunktioner, der hj\u00e6lper tr\u00e6nere med at analysere spillerpr\u00e6stationer. Systemet beregner avancerede statistikker som: - Fairway Hits % : Procentdelen af fairways, spilleren ramte. - Green in Regulation % : Hvor ofte spilleren n\u00e5ede greenen inden for \"Par - 2\". - Hulspil Score : En vigtig funktion i systemet er beregningen af spillerens Hulspil Score, der repr\u00e6senterer gennemsnittet af slag pr. hul i en given runde. For at give en fair vurdering justeres scorer, der er v\u00e6rre end double bogey, automatisk til double bogey, f\u00f8r de indg\u00e5r i beregningen. Dette sikrer, at ekstremsituationer ikke p\u00e5virker gennemsnittet uforholdsm\u00e6ssigt meget (Krav tilf\u00f8jet af PO under udviklingen af systemet). Eksempel p\u00e5 beregning: public double CalculateAvgMatchPlayScorePerRound(List<PlayingHoleDto> playingHoles) { // Group playing holes by roundId var roundScores = playingHoles.GroupBy(ph => ph.RoundId) .Select(g => { double totalAdjustedScore = 0.0; foreach (var ph in g) { // calculate the adjusted score double adjustedScore = ph.Score > (ph.Par + 2) ? (ph.Par + 2) : ph.Score; totalAdjustedScore += adjustedScore; } return totalAdjustedScore; }) .ToList(); // Calculate the avg adjusted score = MatcPlayScoreAvg. return roundScores.Any() ? roundScores.Average() : 0.0; } Disse beregninger pr\u00e6senteres visuelt som grafer og farvekodede tabeller, der g\u00f8r det nemt for tr\u00e6nere at identificere forbedringsomr\u00e5der for deres spillere.","title":"Statistikberegninger og Visualisering"},{"location":"#refleksioner","text":"","title":"Refleksioner"},{"location":"#planlgning-og-mal","text":"Selvom jeg ikke havde en fastlagt skemastruktur, arbejdede jeg med klare m\u00e5l og en overordnet plan, som blev visualiseret ved hj\u00e6lp af et Gantt-diagram. Diagrammet hjalp mig med at organisere mit arbejde og sikre, at jeg holdt fokus p\u00e5 projektets vigtigste leverancer. Planen omfattede faser som: - Analyse og design : Systemanalyse, kravspecifikation og design af systemarkitektur. - Backend-udvikling : Implementering af kernefunktioner, autorisation og statistikberegninger. - Frontend-udvikling : Udvikling af UI-komponenter og integration med backend. - Feedback og iterationer : Justering af l\u00f8sninger baseret p\u00e5 feedback fra Product Owner. Ved at arbejde med planen kunne jeg nemt opdele komplekse opgaver i mindre trin og prioritere dem baseret p\u00e5 deres betydning for projektets l\u00e6ringsm\u00e5l.","title":"Planl\u00e6gning og m\u00e5l"},{"location":"#arbejde-uden-fast-struktur","text":"P\u00e5 trods af den overordnede plan arbejdede jeg uden en fast daglig struktur, hvilket gav mig frihed til at udforske og l\u00e6re i mit eget tempo. Dette var b\u00e5de en styrke og en udfordring. P\u00e5 den ene side kunne jeg fokusere p\u00e5 de omr\u00e5der, der kr\u00e6vede mest opm\u00e6rksomhed, men p\u00e5 den anden side savnede jeg nogle gange en fast rytme til at holde mig fuldt organiseret. Hvis jeg havde arbejdet med en strammere tidsplan, kunne jeg m\u00e5ske have udnyttet tiden endnu mere effektivt.","title":"Arbejde uden fast struktur"},{"location":"#feedback-og-kommunikation","text":"Samarbejdet med Product Owner var en vigtig del af projektet, og feedbacken fra ham gav os flere nyttige indsigter. Under en pr\u00e6sentation viste vi vores API-endpoints ved hj\u00e6lp af Swagger for at demonstrere systemets tekniske funktionalitet. PO n\u00e6vnte dog, at han ikke fik s\u00e5 meget ud af denne tilgang. Han ville have haft mere gavn af en simpel visuel pr\u00e6sentation, s\u00e5som et diagram eller en tegning, der kunne forklare systemets funktioner p\u00e5 et overordnet niveau. Denne oplevelse mindede mig om vigtigheden af at tilpasse kommunikationen til m\u00e5lgruppen. Ikke alle interessenter har behov for dyb teknisk indsigt, og fremover vil jeg fokusere mere p\u00e5 at bruge visuelle v\u00e6rkt\u00f8jer og diagrammer til at formidle komplekse l\u00f8sninger p\u00e5 en mere tilg\u00e6ngelig m\u00e5de. Dette vil sikre, at interessenter forst\u00e5r v\u00e6rdien af l\u00f8sningen og dens anvendelse.","title":"Feedback og kommunikation"},{"location":"#opnaelse-af-lringsmal","text":"Jeg har opn\u00e5et betydelige fremskridt i forhold til mine l\u00e6ringsm\u00e5l, is\u00e6r inden for backend-udvikling og systemarkitektur: Clean Architecture gav mig v\u00e6rdifuld erfaring i at skabe en fleksibel og vedligeholdelsesvenlig kodebase. Jeg l\u00e6rte at opdele applikationen i lag, hvilket gjorde det lettere at implementere nye funktioner og rette fejl. CQRS og Repository Pattern hjalp mig med at skabe en skalerbar og modular backend. Jeg har l\u00e6rt at strukturere koden med tydelig adskillelse af l\u00e6se- og skriveoperationer ved hj\u00e6lp af MediatR, hvilket har gjort min kodebase mere testbar og vedligeholdelsesvenlig. Autorisering og sikkerhed via JWT-tokens gav mig dybere indsigt i moderne sikkerhedsmekanismer. Jeg forstod, hvordan man implementerer sikker kommunikation og begr\u00e6nser adgang til API-endpoints baseret p\u00e5 brugerroller.","title":"Opn\u00e5else af l\u00e6ringsm\u00e5l"},{"location":"#personlig-udvikling","text":"Dette semester har v\u00e6ret en vigtig l\u00e6ringsrejse. Jeg har ikke kun styrket mine tekniske f\u00e6rdigheder, men ogs\u00e5 udviklet en dybere forst\u00e5else af, hvordan man opbygger systemer, der b\u00e5de er robuste og brugervenlige. Arbejdet med komplekse designm\u00f8nstre og teknologier har forbedret min evne til at analysere problemer og finde effektive l\u00f8sninger.","title":"Personlig udvikling"},{"location":"#forbedringsomrader","text":"Strammere tidsstyring : Selvom planen fungerede godt som en guide, kunne jeg have brugt den mere aktivt til at evaluere mit daglige arbejde og sikre, at jeg holdt mig p\u00e5 rette spor. Tilpasning af kommunikation : Denne erfaring med PO viste mig, at kommunikation skal m\u00e5lrettes mod modtagerens behov. Jeg vil fremover bruge flere visuelle v\u00e6rkt\u00f8jer og forberede alternative m\u00e5der at pr\u00e6sentere teknisk komplekse emner. Udvidelse af frontend-kompetencer : Mit fokus har v\u00e6ret p\u00e5 backend, men der er stadig omr\u00e5der i frontend-udviklingen, hvor jeg kan forbedre mine f\u00e6rdigheder, is\u00e6r inden for brugeroplevelse og design.","title":"Forbedringsomr\u00e5der"},{"location":"#konklusion","text":"Min erfaring med dette projekt har v\u00e6ret utrolig l\u00e6rerig. Jeg har f\u00e5et praktisk erfaring med at anvende komplekse designprincipper som Clean Architecture og CQRS samt teknologier som JWT. Samtidig har jeg l\u00e6rt vigtigheden af planl\u00e6gning og struktur for at kunne arbejde effektivt. Denne proces har ogs\u00e5 l\u00e6rt mig at tilpasse min kommunikation til m\u00e5lgruppen, hvilket jeg ser som en uvurderlig f\u00e6rdighed fremover. Dette semester har ikke kun styrket mine tekniske kompetencer, men ogs\u00e5 min evne til at reflektere over mit arbejde og finde m\u00e5der at forbedre det p\u00e5.","title":"Konklusion"},{"location":"Logbog/","text":"Logbog 13. august \u2013 10. oktober: Projektopstart og backend-design Indledning I denne fase designede jeg backend-strukturen til projektet for Odense Golfklub. Fokus var at skabe en robust og skalerbar l\u00f8sning, der underst\u00f8tter datamodellering og effektiv API-kommunikation. Arbejdet inkluderede kravindsamling, planl\u00e6gning og implementering af n\u00f8glefunktioner i backend med v\u00e6gt p\u00e5 modularitet og sikkerhed. L\u00e6ringsm\u00e5l og fokusomr\u00e5der Implementere principperne bag Clean Architecture for at sikre klar ansvarsfordeling mellem applikationens lag. Design og implementering af datamodeller til repr\u00e6sentation af golfbaner, loops og relaterede data. Udvikling af API\u2019er, der underst\u00f8tter sikker kommunikation mellem backend og frontend via JWT-tokens. Tekniske Implementeringer Systemarkitektur: Backend-strukturen blev opdelt i klart definerede lag: Domain: Indeholder kerneentiteter og deres relationer. Application: H\u00e5ndterer use cases og validering. Infrastructure: Sikrer dataadgang via repositories. API: Eksponerer funktionalitet til frontend. Struktur af Clean Architecture : GolfCoachInsight \u2502 \u251c\u2500\u2500 Domain \u2502 \u2514\u2500\u2500 Entities \u2502 \u251c\u2500\u2500 Application \u2502 \u251c\u2500\u2500 Features \u2502 \u251c\u2500\u2500 Validators \u2502 \u251c\u2500\u2500 Contracts \u2502 \u2514\u2500\u2500 Services \u2502 \u251c\u2500\u2500 Infrastructure \u2502 \u251c\u2500\u2500 Persistence \u2502 \u2502 \u2514\u2500\u2500 Repositories \u2502 \u2514\u2500\u2500 API \u2514\u2500\u2500 Controllers Validering og sikkerhed: Backend sikrer dataintegritet med FluentValidation og beskytter endpoints med JWT-tokens. FluentValidation For at validere data, har hver DTO en tilsvarende DtoValidator , hvor jeg ved brug af FluentValidation kan definere brugerdefinerede regler. Eksempelvis validerer f\u00f8lgende klasse, om en golfklubs navn er unikt: public class CreateGolfClubDtoValidator : AbstractValidator<CreateGolfClubDto> { private readonly IGolfClubRepository _golfClubRepository; public CreateGolfClubDtoValidator(IGolfClubRepository golfClubRepository) { _golfClubRepository = golfClubRepository; RuleFor(p => p.Name) .NotEmpty().WithMessage(\"{PropertyName} is required.\") .NotNull().WithMessage(\"{PropertyName} is required and must not be null.\") .MustAsync(async (name, token) => { var golfClubExsist = await _golfClubRepository.IsNameAvailable(name); return golfClubExsist; // Return true, if the name does not exist. }) .WithMessage(\"A golf club with the provided {PropertyName} already exists.\"); } } Denne validering sikrer korrekt input og forhindrer duplikationer ved at tjekke, om golfklubbens navn allerede findes i databasen. JWT-tokenh\u00e5ndtering Backend bruger JWT-tokens til at beskytte API-endpoints og sikre, at kun autoriserede brugere kan f\u00e5 adgang til bestemte ressourcer. For at sikre autentifikationen i API\u2019et, er der konfigureret JWT-validering i Program.cs : services.AddSwaggerGen(c => { c.AddSecurityDefinition(\"Bearer\", new OpenApiSecurityScheme { Description = @\"JWT Authorization header using the Bearer scheme. Enter 'Bearer' [space] and then your token in the text input below. Example: 'Bearer 12345abcdef'\", Name = \"Authorization\", In = ParameterLocation.Header, Type = SecuritySchemeType.ApiKey, Scheme = \"Bearer\" }); c.AddSecurityRequirement(new OpenApiSecurityRequirement() { { new OpenApiSecurityScheme { Reference = new OpenApiReference { Type = ReferenceType.SecurityScheme, Id = \"Bearer\" }, Scheme = \"oauth2\", Name = \"Bearer\", In = ParameterLocation.Header, }, new List<string>() } }); }); Her tilf\u00f8jes en Swagger-integration, der g\u00f8r det muligt for udviklere at autentificere sig selv via JWT-tokens i API-dokumentationen, hvilket sikrer, at kun autoriserede brugere kan f\u00e5 adgang til beskyttede endpoints. Beskyttelse af API-endpoints med [Authorize] Jeg har beskyttet controlleren GolfClubController med [Authorize]-attributten, som s\u00f8rger for, at kun autoriserede brugere kan tilg\u00e5 dens endpoints. Dette kan ogs\u00e5 konfigureres, s\u00e5 kun brugere med specifikke roller (fx \"Admin\") kan udf\u00f8re visse handlinger: namespace GolfCoachInsight.Api.Controllers { [Route(\"api/[controller]\")] [ApiController] // Only authorized users can use this controller [Authorize] public class GolfClubController : ControllerBase { private readonly IMediator _mediator; public GolfClubController(IMediator mediator) { _mediator = mediator; } // GET api/<GolfClubController>/5 [HttpGet(\"{id}\")] public async Task<ActionResult<GolfClubDto>> Get(int id) { var golfClub = await _mediator.Send(new GetGolfClubDetailRequest { Id = id }); return Ok(golfClub); } // POST api/<GolfClubController> [HttpPost] [Authorize(Roles = \"Admin\")] public async Task<ActionResult> Post([FromBody] CreateGolfClubDto golfClub) { var command = new CreateGolfClubCommand { GolfClubDto = golfClub }; var response = await _mediator.Send(command); if (response.Success) { return Ok(response); } else { return BadRequest(response); } } } } GET Endpoint : Tilg\u00e6ngelig for alle autentificerede brugere. POST Endpoint : Kun tilg\u00e6ngelig for brugere med rollen \"Admin\", som beskytter mod uautoriseret oprettelse af golfklubber. Hvorfor det er vigtigt: - JWT beskytter applikationen ved kun at give adgang til autoriserede brugere. - Swagger Integration g\u00f8r det nemt for udviklere at teste API'et med JWT, hvilket giver en praktisk m\u00e5de at validere tokens p\u00e5 under udvikling. - [Authorize] sikrer, at kun godkendte brugere (og specifikt administratorer) kan tilf\u00f8je nye golfklubber til systemet. Kodeintegrationer: API\u2019et blev designet til at underst\u00f8tte foresp\u00f8rgsler og kommandoer med integration til databasen via repositories. Refleksion over l\u00e6ring Implementeringen af Clean Architecture kr\u00e6vede betydeligt mere arbejde i starten, da alle funktioner og data skulle adskilles i klart definerede lag. Denne ekstra indsats gjorde det imidlertid langt nemmere at tilf\u00f8je nye funktioner og \u00e6ndringer senere i projektet. Arbejdet l\u00e6rte mig, hvordan struktureret arkitektur kan skabe en mere vedligeholdelsesvenlig og skalerbar l\u00f8sning. Arbejdet med JWT-tokens gav praktisk erfaring med sikkerhed i API\u2019er, mens valideringsmekanismer sikrede datakvalitet. Jeg blev ogs\u00e5 opm\u00e6rksom p\u00e5, hvordan t\u00e6t samarbejde med Product Owner forbedrer kravforst\u00e5elsen og sikrer en l\u00f8sning, der opfylder brugerens behov. Resultater og effekter En skalerbar backend-struktur, der let kan udvides til fremtidige behov. Etablering af sikre og robuste API\u2019er, der effektivt underst\u00f8tter frontend-kommunikation. Dokumenterede designvalg, som styrker vedligeholdelse og samarbejde. 11. oktober \u2013 5. november: Backend-udvikling og kernefunktionaliteter Indledning I denne periode fokuserede jeg p\u00e5 at refaktorisere koden og tilf\u00f8je nye funktioner, herunder at implementere CQRS til h\u00e5ndtering af kommandoer og foresp\u00f8rgsler. Et konkret eksempel p\u00e5 dette er CreateTeeCommandHandler og GetTeeDetailRequestHandler, som implementerer adskillelse af l\u00e6se- og skriveoperationer. Dette gjorde backend-systemet mere modul\u00e6rt og skalerbart. L\u00e6ringsm\u00e5l og fokusomr\u00e5der Implementere CQRS for at adskille kommandoer og foresp\u00f8rgsler, hvilket muligg\u00f8r bedre kontrol og skalerbarhed. Anvende AutoMapper til at mappe mellem DTO'er og dom\u00e6neobjekter. Validere inddata med FluentValidation og sikre korrekt dataintegritet. Anvende MediatR til at h\u00e5ndtere kommandoer og foresp\u00f8rgsler, hvilket skaber en renere og mere testbar arkitektur. Tekniske Implementeringer CQRS blev implementeret for at adskille CreateTeeCommand (skriveoperation) fra GetTeeDetailRequest (l\u00e6seoperation). Dette g\u00f8r systemet nemmere at udvide og vedligeholde, da kommandoer og foresp\u00f8rgsler er uafh\u00e6ngige af hinanden. CreateTeeCommandHandler : Denne handler h\u00e5ndterer oprettelsen af en ny tee. Den validerer f\u00f8rst dataene ved hj\u00e6lp af CreateTeeDtoValidator , mapper DTO'en til et dom\u00e6neobjekt med AutoMapper, og gemmer objektet i databasen via ITeeRepository. public class CreateTeeCommandHandler : IRequestHandler<CreateTeeCommand, BaseCommandResponse> { private readonly ITeeRepository _teeRepository; private readonly IMapper _mapper; private readonly IHoleRepository _holeRepository; public CreateTeeCommandHandler(ITeeRepository teeRepository, IMapper mapper, IHoleRepository holeRepository) { _teeRepository = teeRepository; _mapper = mapper; _holeRepository = holeRepository; } public async Task<BaseCommandResponse> Handle(CreateTeeCommand request, CancellationToken cancellationToken) { var response = new BaseCommandResponse(); var validator = new CreateTeeDtoValidator(_holeRepository); var validationResult = await validator.ValidateAsync(request.TeeDto); if (!validationResult.IsValid) { response.Success = false; response.Message = \"Creation Failed\"; response.Errors = validationResult.Errors.Select(q => q.ErrorMessage).ToList(); return response; } var tee = _mapper.Map<Domain.Tee>(request.TeeDto); tee = await _teeRepository.Create(tee); response.Success = true; response.Message = \"Creation Successful\"; response.Id = tee.Id; return response; } } GetTeeDetailRequestHandler : Denne handler h\u00e5ndterer foresp\u00f8rgsler om en eksisterende tee. Den henter tee-data fra databasen og mapper den til en TeeDto. public class GetTeeDetailRequestHandler : IRequestHandler<GetTeeDetailRequest, TeeDto> { private readonly ITeeRepository _teeRepository; private readonly IMapper _mapper; public GetTeeDetailRequestHandler(ITeeRepository teeRepository, IMapper mapper) { _teeRepository = teeRepository; _mapper = mapper; } public async Task<TeeDto> Handle(GetTeeDetailRequest request, CancellationToken cancellationToken) { var tee = await _teeRepository.Get(request.Id); return _mapper.Map<TeeDto>(tee); } } Kommando og Foresp\u00f8rgsel: CreateTeeCommand : Bruges til at oprette en ny tee. GetTeeDetailRequest : Bruges til at hente detaljer om en specifik tee. // Kommando public class CreateTeeCommand : IRequest<BaseCommandResponse> { public CreateTeeDto TeeDto { get; set; } } // Foresp\u00f8rgsel public class GetTeeDetailRequest : IRequest<TeeDto> { public int Id { get; set; } } Refleksion over l\u00e6ring Arbejdet med CQRS l\u00e6rte mig at adskille ansvar for l\u00e6se- og skriveoperationer, hvilket gjorde systemet mere fleksibelt og lettere at udvide. Jeg blev mere fortrolig med MediatR, som effektivt h\u00e5ndterer kommandoer og foresp\u00f8rgsler. En af de udfordringer, jeg st\u00f8dte p\u00e5, var at sikre korrekt datavalidering og h\u00e5ndtering af fejlagtige input. Jeg brugte FluentValidation til at implementere brugervenlige fejlmeddelelser og sikre dataintegritet p\u00e5 tv\u00e6rs af alle DtoValidators. Selvom valideringen fungerede som \u00f8nsket, kunne den have v\u00e6ret mere dybdeg\u00e5ende. P\u00e5 grund af tidsbegr\u00e6nsninger og skiftende fokus i projektet blev implementeringen af valideringen prioriteret hurtigt. Dette bet\u00f8d, at der var plads til forbedringer, is\u00e6r n\u00e5r det kommer til mere komplekse valideringsregler og h\u00e5ndtering af specifikke fejlscenarier p\u00e5 tv\u00e6rs af de forskellige DTO\u2019er. Resultater og effekter En robust backend, der effektivt h\u00e5ndterer b\u00e5de kommandoer og foresp\u00f8rgsler. CQRS-strukturen g\u00f8r det nemmere at udvide systemet med nye funktioner uden at forstyrre eksisterende funktionalitet. AutoMapper og FluentValidation blev implementeret effektivt til at h\u00e5ndtere datamapping og validering, hvilket har \u00f8get kodens l\u00e6sbarhed og robusthed. 6. november \u2013 25. november: Frontend-udvikling Indledning I denne fase fokuserede jeg p\u00e5 udviklingen af applikationens frontend ved hj\u00e6lp af Blazor WebAssembly. M\u00e5let var at skabe en dynamisk og brugervenlig gr\u00e6nseflade, der sikrer intuitiv navigation og problemfri integration med backend. L\u00e6ringsm\u00e5l og fokusomr\u00e5der Implementere funktionalitet til sikker brugerautentifikation og autorisation med JWT-tokenh\u00e5ndtering. Udvikle interaktive og brugervenlige komponenter til navigation og datavisualisering. Sikre effektiv kommunikation mellem frontend og backend via API\u2019er. Forbedre brugeroplevelsen gennem dynamisk filtrering og farvekodning af data. Tekniske implementeringer Autentifikation og autorisation : Udviklede login- og registreringssider med h\u00e5ndtering af JWT-tokens, som sikrer sikker adgang til applikationen. Interaktive datavisninger : Implementerede sider som golfkluboversigt, hvor brugerne kan navigere mellem klubber, baner og huldetaljer. Data hentes dynamisk via API-kald. Statistikvisning : Udviklede tabeller, der visualiserer spillerdata med farvekodning baseret p\u00e5 pr\u00e6stationer. Dette giver tr\u00e6nere en hurtig indsigt i spilleres resultater. Navigation og integration : Brugere kan navigere hierarkisk fra golfklubber til baner og videre til huldetaljer. API-integration sikrer sikker og p\u00e5lidelig dataoverf\u00f8rsel mellem frontend og backend. Refleksion over l\u00e6ring Udviklingen af frontend har givet mig en solid forst\u00e5else af Blazor WebAssembly. Jeg har forbedret mine evner i at integrere frontend og backend via API\u2019er, samtidig med at jeg l\u00e6rte at skabe brugervenlige l\u00f8sninger. Resultater og effekter En dynamisk og brugervenlig frontend, der underst\u00f8tter avanceret funktionalitet som filtrering og statistikvisning. Problemfri integration mellem frontend og backend via API-kald. Effektiv datavisualisering og navigation, der forbedrer brugeroplevelsen.","title":"Logbog"},{"location":"Logbog/#logbog","text":"","title":"Logbog"},{"location":"Logbog/#13-august-10-oktober-projektopstart-og-backend-design","text":"","title":"13. august \u2013 10. oktober: Projektopstart og backend-design"},{"location":"Logbog/#indledning","text":"I denne fase designede jeg backend-strukturen til projektet for Odense Golfklub. Fokus var at skabe en robust og skalerbar l\u00f8sning, der underst\u00f8tter datamodellering og effektiv API-kommunikation. Arbejdet inkluderede kravindsamling, planl\u00e6gning og implementering af n\u00f8glefunktioner i backend med v\u00e6gt p\u00e5 modularitet og sikkerhed.","title":"Indledning"},{"location":"Logbog/#lringsmal-og-fokusomrader","text":"Implementere principperne bag Clean Architecture for at sikre klar ansvarsfordeling mellem applikationens lag. Design og implementering af datamodeller til repr\u00e6sentation af golfbaner, loops og relaterede data. Udvikling af API\u2019er, der underst\u00f8tter sikker kommunikation mellem backend og frontend via JWT-tokens.","title":"L\u00e6ringsm\u00e5l og fokusomr\u00e5der"},{"location":"Logbog/#tekniske-implementeringer","text":"Systemarkitektur: Backend-strukturen blev opdelt i klart definerede lag: Domain: Indeholder kerneentiteter og deres relationer. Application: H\u00e5ndterer use cases og validering. Infrastructure: Sikrer dataadgang via repositories. API: Eksponerer funktionalitet til frontend. Struktur af Clean Architecture : GolfCoachInsight \u2502 \u251c\u2500\u2500 Domain \u2502 \u2514\u2500\u2500 Entities \u2502 \u251c\u2500\u2500 Application \u2502 \u251c\u2500\u2500 Features \u2502 \u251c\u2500\u2500 Validators \u2502 \u251c\u2500\u2500 Contracts \u2502 \u2514\u2500\u2500 Services \u2502 \u251c\u2500\u2500 Infrastructure \u2502 \u251c\u2500\u2500 Persistence \u2502 \u2502 \u2514\u2500\u2500 Repositories \u2502 \u2514\u2500\u2500 API \u2514\u2500\u2500 Controllers Validering og sikkerhed: Backend sikrer dataintegritet med FluentValidation og beskytter endpoints med JWT-tokens.","title":"Tekniske Implementeringer"},{"location":"Logbog/#fluentvalidation","text":"For at validere data, har hver DTO en tilsvarende DtoValidator , hvor jeg ved brug af FluentValidation kan definere brugerdefinerede regler. Eksempelvis validerer f\u00f8lgende klasse, om en golfklubs navn er unikt: public class CreateGolfClubDtoValidator : AbstractValidator<CreateGolfClubDto> { private readonly IGolfClubRepository _golfClubRepository; public CreateGolfClubDtoValidator(IGolfClubRepository golfClubRepository) { _golfClubRepository = golfClubRepository; RuleFor(p => p.Name) .NotEmpty().WithMessage(\"{PropertyName} is required.\") .NotNull().WithMessage(\"{PropertyName} is required and must not be null.\") .MustAsync(async (name, token) => { var golfClubExsist = await _golfClubRepository.IsNameAvailable(name); return golfClubExsist; // Return true, if the name does not exist. }) .WithMessage(\"A golf club with the provided {PropertyName} already exists.\"); } } Denne validering sikrer korrekt input og forhindrer duplikationer ved at tjekke, om golfklubbens navn allerede findes i databasen.","title":"FluentValidation"},{"location":"Logbog/#jwt-tokenhandtering","text":"Backend bruger JWT-tokens til at beskytte API-endpoints og sikre, at kun autoriserede brugere kan f\u00e5 adgang til bestemte ressourcer. For at sikre autentifikationen i API\u2019et, er der konfigureret JWT-validering i Program.cs : services.AddSwaggerGen(c => { c.AddSecurityDefinition(\"Bearer\", new OpenApiSecurityScheme { Description = @\"JWT Authorization header using the Bearer scheme. Enter 'Bearer' [space] and then your token in the text input below. Example: 'Bearer 12345abcdef'\", Name = \"Authorization\", In = ParameterLocation.Header, Type = SecuritySchemeType.ApiKey, Scheme = \"Bearer\" }); c.AddSecurityRequirement(new OpenApiSecurityRequirement() { { new OpenApiSecurityScheme { Reference = new OpenApiReference { Type = ReferenceType.SecurityScheme, Id = \"Bearer\" }, Scheme = \"oauth2\", Name = \"Bearer\", In = ParameterLocation.Header, }, new List<string>() } }); }); Her tilf\u00f8jes en Swagger-integration, der g\u00f8r det muligt for udviklere at autentificere sig selv via JWT-tokens i API-dokumentationen, hvilket sikrer, at kun autoriserede brugere kan f\u00e5 adgang til beskyttede endpoints.","title":"JWT-tokenh\u00e5ndtering"},{"location":"Logbog/#beskyttelse-af-api-endpoints-med-authorize","text":"Jeg har beskyttet controlleren GolfClubController med [Authorize]-attributten, som s\u00f8rger for, at kun autoriserede brugere kan tilg\u00e5 dens endpoints. Dette kan ogs\u00e5 konfigureres, s\u00e5 kun brugere med specifikke roller (fx \"Admin\") kan udf\u00f8re visse handlinger: namespace GolfCoachInsight.Api.Controllers { [Route(\"api/[controller]\")] [ApiController] // Only authorized users can use this controller [Authorize] public class GolfClubController : ControllerBase { private readonly IMediator _mediator; public GolfClubController(IMediator mediator) { _mediator = mediator; } // GET api/<GolfClubController>/5 [HttpGet(\"{id}\")] public async Task<ActionResult<GolfClubDto>> Get(int id) { var golfClub = await _mediator.Send(new GetGolfClubDetailRequest { Id = id }); return Ok(golfClub); } // POST api/<GolfClubController> [HttpPost] [Authorize(Roles = \"Admin\")] public async Task<ActionResult> Post([FromBody] CreateGolfClubDto golfClub) { var command = new CreateGolfClubCommand { GolfClubDto = golfClub }; var response = await _mediator.Send(command); if (response.Success) { return Ok(response); } else { return BadRequest(response); } } } } GET Endpoint : Tilg\u00e6ngelig for alle autentificerede brugere. POST Endpoint : Kun tilg\u00e6ngelig for brugere med rollen \"Admin\", som beskytter mod uautoriseret oprettelse af golfklubber. Hvorfor det er vigtigt: - JWT beskytter applikationen ved kun at give adgang til autoriserede brugere. - Swagger Integration g\u00f8r det nemt for udviklere at teste API'et med JWT, hvilket giver en praktisk m\u00e5de at validere tokens p\u00e5 under udvikling. - [Authorize] sikrer, at kun godkendte brugere (og specifikt administratorer) kan tilf\u00f8je nye golfklubber til systemet. Kodeintegrationer: API\u2019et blev designet til at underst\u00f8tte foresp\u00f8rgsler og kommandoer med integration til databasen via repositories.","title":"Beskyttelse af API-endpoints med [Authorize]"},{"location":"Logbog/#refleksion-over-lring","text":"Implementeringen af Clean Architecture kr\u00e6vede betydeligt mere arbejde i starten, da alle funktioner og data skulle adskilles i klart definerede lag. Denne ekstra indsats gjorde det imidlertid langt nemmere at tilf\u00f8je nye funktioner og \u00e6ndringer senere i projektet. Arbejdet l\u00e6rte mig, hvordan struktureret arkitektur kan skabe en mere vedligeholdelsesvenlig og skalerbar l\u00f8sning. Arbejdet med JWT-tokens gav praktisk erfaring med sikkerhed i API\u2019er, mens valideringsmekanismer sikrede datakvalitet. Jeg blev ogs\u00e5 opm\u00e6rksom p\u00e5, hvordan t\u00e6t samarbejde med Product Owner forbedrer kravforst\u00e5elsen og sikrer en l\u00f8sning, der opfylder brugerens behov.","title":"Refleksion over l\u00e6ring"},{"location":"Logbog/#resultater-og-effekter","text":"En skalerbar backend-struktur, der let kan udvides til fremtidige behov. Etablering af sikre og robuste API\u2019er, der effektivt underst\u00f8tter frontend-kommunikation. Dokumenterede designvalg, som styrker vedligeholdelse og samarbejde.","title":"Resultater og effekter"},{"location":"Logbog/#11-oktober-5-november-backend-udvikling-og-kernefunktionaliteter","text":"","title":"11. oktober \u2013 5. november: Backend-udvikling og kernefunktionaliteter"},{"location":"Logbog/#indledning_1","text":"I denne periode fokuserede jeg p\u00e5 at refaktorisere koden og tilf\u00f8je nye funktioner, herunder at implementere CQRS til h\u00e5ndtering af kommandoer og foresp\u00f8rgsler. Et konkret eksempel p\u00e5 dette er CreateTeeCommandHandler og GetTeeDetailRequestHandler, som implementerer adskillelse af l\u00e6se- og skriveoperationer. Dette gjorde backend-systemet mere modul\u00e6rt og skalerbart.","title":"Indledning"},{"location":"Logbog/#lringsmal-og-fokusomrader_1","text":"Implementere CQRS for at adskille kommandoer og foresp\u00f8rgsler, hvilket muligg\u00f8r bedre kontrol og skalerbarhed. Anvende AutoMapper til at mappe mellem DTO'er og dom\u00e6neobjekter. Validere inddata med FluentValidation og sikre korrekt dataintegritet. Anvende MediatR til at h\u00e5ndtere kommandoer og foresp\u00f8rgsler, hvilket skaber en renere og mere testbar arkitektur.","title":"L\u00e6ringsm\u00e5l og fokusomr\u00e5der"},{"location":"Logbog/#tekniske-implementeringer_1","text":"CQRS blev implementeret for at adskille CreateTeeCommand (skriveoperation) fra GetTeeDetailRequest (l\u00e6seoperation). Dette g\u00f8r systemet nemmere at udvide og vedligeholde, da kommandoer og foresp\u00f8rgsler er uafh\u00e6ngige af hinanden.","title":"Tekniske Implementeringer"},{"location":"Logbog/#createteecommandhandler","text":"Denne handler h\u00e5ndterer oprettelsen af en ny tee. Den validerer f\u00f8rst dataene ved hj\u00e6lp af CreateTeeDtoValidator , mapper DTO'en til et dom\u00e6neobjekt med AutoMapper, og gemmer objektet i databasen via ITeeRepository. public class CreateTeeCommandHandler : IRequestHandler<CreateTeeCommand, BaseCommandResponse> { private readonly ITeeRepository _teeRepository; private readonly IMapper _mapper; private readonly IHoleRepository _holeRepository; public CreateTeeCommandHandler(ITeeRepository teeRepository, IMapper mapper, IHoleRepository holeRepository) { _teeRepository = teeRepository; _mapper = mapper; _holeRepository = holeRepository; } public async Task<BaseCommandResponse> Handle(CreateTeeCommand request, CancellationToken cancellationToken) { var response = new BaseCommandResponse(); var validator = new CreateTeeDtoValidator(_holeRepository); var validationResult = await validator.ValidateAsync(request.TeeDto); if (!validationResult.IsValid) { response.Success = false; response.Message = \"Creation Failed\"; response.Errors = validationResult.Errors.Select(q => q.ErrorMessage).ToList(); return response; } var tee = _mapper.Map<Domain.Tee>(request.TeeDto); tee = await _teeRepository.Create(tee); response.Success = true; response.Message = \"Creation Successful\"; response.Id = tee.Id; return response; } }","title":"CreateTeeCommandHandler:"},{"location":"Logbog/#getteedetailrequesthandler","text":"Denne handler h\u00e5ndterer foresp\u00f8rgsler om en eksisterende tee. Den henter tee-data fra databasen og mapper den til en TeeDto. public class GetTeeDetailRequestHandler : IRequestHandler<GetTeeDetailRequest, TeeDto> { private readonly ITeeRepository _teeRepository; private readonly IMapper _mapper; public GetTeeDetailRequestHandler(ITeeRepository teeRepository, IMapper mapper) { _teeRepository = teeRepository; _mapper = mapper; } public async Task<TeeDto> Handle(GetTeeDetailRequest request, CancellationToken cancellationToken) { var tee = await _teeRepository.Get(request.Id); return _mapper.Map<TeeDto>(tee); } }","title":"GetTeeDetailRequestHandler:"},{"location":"Logbog/#kommando-og-foresprgsel","text":"CreateTeeCommand : Bruges til at oprette en ny tee. GetTeeDetailRequest : Bruges til at hente detaljer om en specifik tee. // Kommando public class CreateTeeCommand : IRequest<BaseCommandResponse> { public CreateTeeDto TeeDto { get; set; } } // Foresp\u00f8rgsel public class GetTeeDetailRequest : IRequest<TeeDto> { public int Id { get; set; } }","title":"Kommando og Foresp\u00f8rgsel:"},{"location":"Logbog/#refleksion-over-lring_1","text":"Arbejdet med CQRS l\u00e6rte mig at adskille ansvar for l\u00e6se- og skriveoperationer, hvilket gjorde systemet mere fleksibelt og lettere at udvide. Jeg blev mere fortrolig med MediatR, som effektivt h\u00e5ndterer kommandoer og foresp\u00f8rgsler. En af de udfordringer, jeg st\u00f8dte p\u00e5, var at sikre korrekt datavalidering og h\u00e5ndtering af fejlagtige input. Jeg brugte FluentValidation til at implementere brugervenlige fejlmeddelelser og sikre dataintegritet p\u00e5 tv\u00e6rs af alle DtoValidators. Selvom valideringen fungerede som \u00f8nsket, kunne den have v\u00e6ret mere dybdeg\u00e5ende. P\u00e5 grund af tidsbegr\u00e6nsninger og skiftende fokus i projektet blev implementeringen af valideringen prioriteret hurtigt. Dette bet\u00f8d, at der var plads til forbedringer, is\u00e6r n\u00e5r det kommer til mere komplekse valideringsregler og h\u00e5ndtering af specifikke fejlscenarier p\u00e5 tv\u00e6rs af de forskellige DTO\u2019er.","title":"Refleksion over l\u00e6ring"},{"location":"Logbog/#resultater-og-effekter_1","text":"En robust backend, der effektivt h\u00e5ndterer b\u00e5de kommandoer og foresp\u00f8rgsler. CQRS-strukturen g\u00f8r det nemmere at udvide systemet med nye funktioner uden at forstyrre eksisterende funktionalitet. AutoMapper og FluentValidation blev implementeret effektivt til at h\u00e5ndtere datamapping og validering, hvilket har \u00f8get kodens l\u00e6sbarhed og robusthed.","title":"Resultater og effekter"},{"location":"Logbog/#6-november-25-november-frontend-udvikling","text":"","title":"6. november \u2013 25. november: Frontend-udvikling"},{"location":"Logbog/#indledning_2","text":"I denne fase fokuserede jeg p\u00e5 udviklingen af applikationens frontend ved hj\u00e6lp af Blazor WebAssembly. M\u00e5let var at skabe en dynamisk og brugervenlig gr\u00e6nseflade, der sikrer intuitiv navigation og problemfri integration med backend.","title":"Indledning"},{"location":"Logbog/#lringsmal-og-fokusomrader_2","text":"Implementere funktionalitet til sikker brugerautentifikation og autorisation med JWT-tokenh\u00e5ndtering. Udvikle interaktive og brugervenlige komponenter til navigation og datavisualisering. Sikre effektiv kommunikation mellem frontend og backend via API\u2019er. Forbedre brugeroplevelsen gennem dynamisk filtrering og farvekodning af data.","title":"L\u00e6ringsm\u00e5l og fokusomr\u00e5der"},{"location":"Logbog/#tekniske-implementeringer_2","text":"Autentifikation og autorisation : Udviklede login- og registreringssider med h\u00e5ndtering af JWT-tokens, som sikrer sikker adgang til applikationen. Interaktive datavisninger : Implementerede sider som golfkluboversigt, hvor brugerne kan navigere mellem klubber, baner og huldetaljer. Data hentes dynamisk via API-kald. Statistikvisning : Udviklede tabeller, der visualiserer spillerdata med farvekodning baseret p\u00e5 pr\u00e6stationer. Dette giver tr\u00e6nere en hurtig indsigt i spilleres resultater. Navigation og integration : Brugere kan navigere hierarkisk fra golfklubber til baner og videre til huldetaljer. API-integration sikrer sikker og p\u00e5lidelig dataoverf\u00f8rsel mellem frontend og backend.","title":"Tekniske implementeringer"},{"location":"Logbog/#refleksion-over-lring_2","text":"Udviklingen af frontend har givet mig en solid forst\u00e5else af Blazor WebAssembly. Jeg har forbedret mine evner i at integrere frontend og backend via API\u2019er, samtidig med at jeg l\u00e6rte at skabe brugervenlige l\u00f8sninger.","title":"Refleksion over l\u00e6ring"},{"location":"Logbog/#resultater-og-effekter_2","text":"En dynamisk og brugervenlig frontend, der underst\u00f8tter avanceret funktionalitet som filtrering og statistikvisning. Problemfri integration mellem frontend og backend via API-kald. Effektiv datavisualisering og navigation, der forbedrer brugeroplevelsen.","title":"Resultater og effekter"}]}